<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Media Card Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>Social Media Card Generator</h1>
            <p class="subheader">Create social media infographics on fighting disinformation.</p>
        </header>

        <div id="loading" class="loading">Loading card data...</div>

        <div id="card-grid" class="card-grid"></div>

        <div class="global-actions">
            <div class="control-group global-format">
                <label for="global-format-select">Download Format:</label>
                <select id="global-format-select">
                    <option value="square">Square (1:1)</option>
                    <option value="portrait">Portrait (4:5)</option>
                    <option value="story">Story (9:16)</option>
                </select>
            </div>
            <button id="download-all-btn" class="download-all-btn">Generate & Download All Cards</button>
        </div>
    </div>

    <script src="cardData.js"></script>
    <script>
        const categoryImages = {
            'INTRODUCTION': new Image(),
            'EMOTIONAL MANIPULATION': new Image(),
            'COGNITIVE EXPLOITATION': new Image(),
            'SOCIAL & GROUP MANIPULATION': new Image(),
            'LANGUAGE & COMMUNICATION': new Image(),
            'INFORMATION CONTROL': new Image(),
            'CRISIS & FEAR TACTICS': new Image(),
            'AUTHORITY & CREDIBILITY': new Image(),
            'ADVANCED PSYCHOLOGICAL OPERATIONS': new Image(),
            'COUNTER-STRATEGIES & DEFENSE': new Image()
        };
        function loadCategoryImages() {
            categoryImages['INTRODUCTION'].src = 'images/introduction.jfif';
            categoryImages['EMOTIONAL MANIPULATION'].src = 'images/emotional-manipulation.jfif';
            categoryImages['COGNITIVE EXPLOITATION'].src = 'images/cognitive-exploitation.jfif';
            categoryImages['SOCIAL & GROUP MANIPULATION'].src = 'images/social-and-group-manipulation.jfif';
            categoryImages['LANGUAGE & COMMUNICATION'].src = 'images/language-and-communication.jfif';
            categoryImages['INFORMATION CONTROL'].src = 'images/information-control.jfif';
            categoryImages['CRISIS & FEAR TACTICS'].src = 'images/crisis-and-fear-tactics.jfif';
            categoryImages['AUTHORITY & CREDIBILITY'].src = 'images/authority-and-credibility.jfif';
            categoryImages['ADVANCED PSYCHOLOGICAL OPERATIONS'].src = 'images/advanced-psychological-operations.jfif';
            categoryImages['COUNTER-STRATEGIES & DEFENSE'].src = 'images/counter-strategies-and-defense.jfif';

            // Any custom watermarks would be loaded here as well
            // categoryImages['SPECIAL_CUSTOM_IMAGE'].src = 'images/special-image.jfif';
        }
        // Card layouts and themes
        const LAYOUTS = [
            { id: 'layout-centered', name: 'Centered' },
            { id: 'layout-split', name: 'Split' },
            { id: 'layout-boxed', name: 'Boxed' }
        ];

        const THEMES = [
            { id: 'theme-blue', name: 'Blue' },
            { id: 'theme-green', name: 'Green' },
            { id: 'theme-purple', name: 'Purple' },
            { id: 'theme-dark', name: 'Dark' },
            { id: 'theme-sunset', name: 'Sunset' }
        ];

        // Add orientation constants after existing LAYOUTS and THEMES
        const ORIENTATIONS = [
            { id: 'square', name: 'Square (1:1)', width: 1024, height: 1024 },
            { id: 'portrait', name: 'Portrait (4:5)', width: 1024, height: 1280 },
            { id: 'story', name: 'Story (9:16)', width: 1080, height: 1920 }  // Instagram Story dimensions
        ];

        // DOM Elements
        const cardGrid = document.getElementById('card-grid');
        const loadingElement = document.getElementById('loading');
        const downloadAllBtn = document.getElementById('download-all-btn');

        // Store card data globally
        let cardData = [];

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            // Load card data from JSON
            fetchCardData();

            loadCategoryImages();
            // Set up event listeners
            downloadAllBtn.addEventListener('click', downloadAllCards);
        });

        /**
         * Fetch card data from JSON file
         */
        async function fetchCardData() {
            try {
                // Instead of fetching a JSON file, use the data from cardData.js
                if (typeof CARD_DATA !== 'undefined') {
                    cardData = CARD_DATA;

                    // Hide loading indicator
                    loadingElement.style.display = 'none';

                    // Generate card previews
                    generateCardPreviews(cardData);
                } else {
                    throw new Error('Card data not loaded');
                }
            } catch (error) {
                console.error('Error loading card data:', error);

                // Show error in UI
                loadingElement.textContent = 'Error loading card data. Using sample data instead.';

                // Use sample data as fallback
                cardData = getSampleCardData();

                // Hide loading indicator after a delay
                setTimeout(() => {
                    loadingElement.style.display = 'none';

                    // Generate card previews with sample data
                    generateCardPreviews(cardData);
                }, 1500);
            }
        }

        /**
         * Get sample card data (fallback if JSON loading fails)
         */
        function getSampleCardData() {
            return [
                {
                    "title": "Climate Facts",
                    "points": [
                        "97% of scientists agree climate change is human-caused",
                        "Global temperatures have risen 1.1Â°C since pre-industrial times",
                        "Sea levels rose 8-9 inches since 1880"
                    ],
                    "layout": "layout-centered",
                    "theme": "theme-blue"
                },
                {
                    "title": "Media Literacy Tips",
                    "points": [
                        "Verify sources before sharing",
                        "Check publication dates",
                        "Look for multiple confirming sources",
                        "Be wary of emotionally manipulative content"
                    ],
                    "layout": "layout-split",
                    "theme": "theme-green"
                },
                {
                    "title": "Spotting Deepfakes",
                    "points": [
                        "Look for unnatural eye movements",
                        "Watch for strange facial expressions",
                        "Check for audio-visual sync issues",
                        "Verify with trusted news sources"
                    ],
                    "layout": "layout-boxed",
                    "theme": "theme-purple"
                }
            ];
        }

        /**
         * Generate card previews for each item in the data
         */
        function generateCardPreviews(data) {
            // Clear existing cards
            cardGrid.innerHTML = '';

            // Generate a preview for each card
            data.forEach((card, index) => {
                const cardPreviewElement = createCardPreviewElement(card, index);
                cardGrid.appendChild(cardPreviewElement);
            });
        }

        /**
         * Create a card preview element
         */
        function createCardPreviewElement(card, index) {
            // Create container for the card preview
            const cardPreview = document.createElement('div');
            cardPreview.className = 'card-preview';
            cardPreview.dataset.index = index;

            // Create header with title
            const cardPreviewHeader = document.createElement('div');
            cardPreviewHeader.className = 'card-preview-header';

            const cardTitle = document.createElement('div');
            cardTitle.className = 'card-title';
            cardTitle.textContent = card.title;

            cardPreviewHeader.appendChild(cardTitle);
            cardPreview.appendChild(cardPreviewHeader);

            // Create canvas container
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'card-canvas-container';

            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'card-canvas-wrapper';

            const canvas = document.createElement('canvas');
            canvas.className = 'card-canvas';
            canvas.width = 1024;
            canvas.height = 1024;
            canvas.id = `canvas-${index}`;

            canvasWrapper.appendChild(canvas);
            canvasContainer.appendChild(canvasWrapper);
            cardPreview.appendChild(canvasContainer);

            // Create controls
            const controls = document.createElement('div');
            controls.className = 'card-controls';

            // Layout selection
            const layoutGroup = document.createElement('div');
            layoutGroup.className = 'control-group';

            const layoutLabel = document.createElement('label');
            layoutLabel.textContent = 'Layout:';
            layoutLabel.htmlFor = `layout-select-${index}`;

            const layoutSelect = document.createElement('select');
            layoutSelect.id = `layout-select-${index}`;
            layoutSelect.addEventListener('change', () => updateCardPreview(index));

            // Create options for each layout
            LAYOUTS.forEach(layout => {
                const option = document.createElement('option');
                option.value = layout.id;
                option.textContent = layout.name;
                option.selected = card.layout === layout.id;
                layoutSelect.appendChild(option);
            });

            layoutGroup.appendChild(layoutLabel);
            layoutGroup.appendChild(layoutSelect);
            controls.appendChild(layoutGroup);

            // Theme selection
            const themeGroup = document.createElement('div');
            themeGroup.className = 'control-group';

            const themeLabel = document.createElement('label');
            themeLabel.textContent = 'Theme:';
            themeLabel.htmlFor = `theme-select-${index}`;

            const themeSelect = document.createElement('select');
            themeSelect.id = `theme-select-${index}`;
            themeSelect.addEventListener('change', () => updateCardPreview(index));

            // Create options for each theme
            THEMES.forEach(theme => {
                const option = document.createElement('option');
                option.value = theme.id;
                option.textContent = theme.name;
                option.selected = card.theme === theme.id;
                themeSelect.appendChild(option);
            });

            themeGroup.appendChild(themeLabel);
            themeGroup.appendChild(themeSelect);
            controls.appendChild(themeGroup);

            // Add orientation selection before download button
            const orientationGroup = document.createElement('div');
            orientationGroup.className = 'control-group';

            const orientationLabel = document.createElement('label');
            orientationLabel.textContent = 'Format:';
            orientationLabel.htmlFor = `orientation-select-${index}`;

            const orientationSelect = document.createElement('select');
            orientationSelect.id = `orientation-select-${index}`;
            orientationSelect.addEventListener('change', () => {
                updateCanvasSize(index);
                updateCardPreview(index);
            });

            // Create options for each orientation
            ORIENTATIONS.forEach(orientation => {
                const option = document.createElement('option');
                option.value = orientation.id;
                option.textContent = orientation.name;
                orientationSelect.appendChild(option);
            });

            orientationGroup.appendChild(orientationLabel);
            orientationGroup.appendChild(orientationSelect);
            controls.appendChild(orientationGroup);

            // Download individual card button
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'download-btn';
            downloadBtn.textContent = 'Download this card';
            downloadBtn.addEventListener('click', () => downloadCard(index));
            controls.appendChild(downloadBtn);

            cardPreview.appendChild(controls);

            // Render initial preview
            setTimeout(() => {
                updateCardPreview(index);
            }, 100);

            return cardPreview;
        }

        // Add function to update canvas size based on orientation
        function updateCanvasSize(index) {
            const canvas = document.getElementById(`canvas-${index}`);
            const orientationSelect = document.getElementById(`orientation-select-${index}`);
            const selectedOrientation = ORIENTATIONS.find(o => o.id === orientationSelect.value);

            canvas.width = selectedOrientation.width;
            canvas.height = selectedOrientation.height;
        }

        /**
         * Update the card preview based on selected layout and theme
         */
        function updateCardPreview(index) {
            const card = cardData[index];
            const canvas = document.getElementById(`canvas-${index}`);
            const layoutSelect = document.getElementById(`layout-select-${index}`);
            const themeSelect = document.getElementById(`theme-select-${index}`);

            // Update card data with current selections
            card.layout = layoutSelect.value;
            card.theme = themeSelect.value;

            // Render the card on the canvas
            renderCardToCanvas(canvas, card);
        }

        /**
         * Render a card to a canvas element
         */
        function renderCardToCanvas(canvas, card) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Get layout and theme styles
            const layoutClass = card.layout || 'layout-centered';
            const themeClass = card.theme || 'theme-blue';

            // Create a temporary div to apply CSS styles
            const tempDiv = document.createElement('div');
            tempDiv.className = `card-content ${layoutClass} ${themeClass}`;
            tempDiv.style.width = `${width}px`;
            tempDiv.style.height = `${height}px`;

            let backgroundColor, color;

            try {
                // Append the div to get computed styles
                document.body.appendChild(tempDiv);

                // Get computed styles
                const styles = window.getComputedStyle(tempDiv);
                backgroundColor = styles.backgroundColor;
                color = styles.color;
            } finally {
                // Always remove the temporary div, even if an error occurs
                if (tempDiv.parentNode) {
                    document.body.removeChild(tempDiv);
                }
            }

            // Apply theme-specific background color overrides
            backgroundColor = getThemeBackgroundColor(themeClass, backgroundColor);

            // Just draw with the solid background:
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, width, height);

            // Now apply gradient on top
            const gradient = createCardGradient(ctx, width, height, backgroundColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            drawWatermark(ctx, width, height, card);

            // Adjust spacing based on aspect ratio
            const aspectRatio = height / width;
            const isPortrait = aspectRatio > 1;

            // Adjust title Y position for portrait mode
            if (isPortrait) {
                if (layoutClass === 'layout-centered') {
                    titleY = 250; // Move title down in portrait mode
                } else if (layoutClass === 'layout-split') {
                    titleY = 175; // Adjust split layout title position
                } else if (layoutClass === 'layout-boxed') {
                    titleBoxY = 150; // Adjust boxed layout title position
                }
            }

            // Get orientation type
            const orientationSelect = document.getElementById(`orientation-select-${canvas.id.split('-')[1]}`);
            const isStoryMode = orientationSelect?.value === 'story';

            // Adjust font sizes and spacing for story mode
            const titleFontSize = isStoryMode ? 72 : 56; // Larger title for stories
            const bodyFontSize = isStoryMode ? 42 : 32;  // Larger body text for stories
            const topPadding = isStoryMode ? 250 : 100;  // Extra padding for story UI

            // Update layout-specific positions
            if (isStoryMode) {
                if (layoutClass === 'layout-centered') {
                    titleY = topPadding;
                } else if (layoutClass === 'layout-split') {
                    titleY = topPadding - 50;
                } else if (layoutClass === 'layout-boxed') {
                    titleBoxY = topPadding - 75;
                }
            }

            // Draw content based on layout with story mode adjustments
            if (layoutClass === 'layout-centered') {
                renderCenteredLayout(ctx, width, height, card, color, isStoryMode, {
                    titleFontSize,
                    bodyFontSize,
                    topPadding
                });
            } else if (layoutClass === 'layout-split') {
                renderSplitLayout(ctx, width, height, card, color, isStoryMode, {
                    titleFontSize,
                    bodyFontSize,
                    topPadding
                });
            } else if (layoutClass === 'layout-boxed') {
                renderBoxedLayout(ctx, width, height, card, color, isStoryMode, {
                    titleFontSize,
                    bodyFontSize,
                    topPadding
                });
            }
        }

        // Add this helper function for text wrapping

        /**
         * Wrap text to fit within a specified width
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         * @param {string} text - Text to wrap
         * @param {number} maxWidth - Maximum width in pixels
         * @return {string[]} Array of lines
         */
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + ' ' + word).width;

                if (width < maxWidth) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }

            lines.push(currentLine);
            return lines;
        }

        // Add this function after the wrapText function
        /**
         * Create a radial gradient background
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         * @param {number} width - Canvas width
         * @param {number} height - Canvas height
         * @param {string} backgroundColor - Base background color
         * @return {CanvasGradient} The gradient object
         */
        function createCardGradient(ctx, width, height, backgroundColor) {
            // Fix transparency issues by ensuring solid background
            // Check if the color includes transparency (rgba)
            if (backgroundColor.includes('rgba')) {
                // Convert any rgba colors to solid rgb equivalents
                const matches = backgroundColor.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/);
                if (matches) {
                    // Create solid version of the color
                    backgroundColor = `rgb(${matches[1]}, ${matches[2]}, ${matches[3]})`;
                }
            }

            // Calculate center and radius
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.max(width, height) * 0.7;

            // Create gradient from center to edges
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius
            );

            // Use solid colors for the gradient
            const centerColor = lightenColor(backgroundColor, 0.12);
            const edgeColor = backgroundColor;

            // Add color stops with a more dramatic transition
            gradient.addColorStop(0, centerColor);
            gradient.addColorStop(0.7, lightenColor(backgroundColor, 0.1));
            gradient.addColorStop(1, edgeColor);

            return gradient;
        }

        /**
         * Lighten a color by a given percentage
         * @param {string} color - CSS color string
         * @param {number} amount - Amount to lighten (0-1)
         * @return {string} Lightened color
         */
        function lightenColor(color, amount) {
            // Handle rgba colors
            if (color.startsWith('rgba')) {
                const parts = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (!parts) return color;

                const r = Math.min(255, parseInt(parts[1]) + Math.round(amount * 255));
                const g = Math.min(255, parseInt(parts[2]) + Math.round(amount * 255));
                const b = Math.min(255, parseInt(parts[3]) + Math.round(amount * 255));
                const a = parts[4] || 1;

                return `rgba(${r}, ${g}, ${b}, ${a})`;
            }

            // Handle hex colors
            if (color.startsWith('#')) {
                let r = parseInt(color.slice(1, 3), 16);
                let g = parseInt(color.slice(3, 5), 16);
                let b = parseInt(color.slice(5, 7), 16);

                r = Math.min(255, r + Math.round(amount * 255));
                g = Math.min(255, g + Math.round(amount * 255));
                b = Math.min(255, b + Math.round(amount * 255));

                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            return color; // Return original if format not recognized
        }

        // Add this helper function right after the lightenColor function
        /**
         * Get the correct background color for a theme, ensuring solid colors for all themes
         * @param {string} themeClass - The theme class name
         * @param {string} backgroundColor - The computed background color
         * @return {string} The solid background color to use
         */
        function getThemeBackgroundColor(themeClass, backgroundColor) {
            // Define custom solid background colors for each theme
            switch (themeClass) {
                case 'theme-blue':
                    return '#e6f2ff'; // Light blue base

                case 'theme-green':
                    return '#e6f7e6'; // Light green base

                case 'theme-purple':
                    return '#f0e6ff'; // Light purple base

                case 'theme-dark':
                    return '#333333'; // Much darker gray base for dark theme

                case 'theme-sunset':
                    return '#ffead0'; // Light warm/peach base

                case 'theme-red':
                    return '#fff0f0'; // Light red/pink base

                default:
                    // For themes without specific overrides, ensure no transparency
                    if (backgroundColor.includes('rgba')) {
                        const matches = backgroundColor.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/);
                        if (matches) {
                            return `rgb(${matches[1]}, ${matches[2]}, ${matches[3]})`;
                        }
                    }
                    return backgroundColor;
            }
        }

        /**
         * Render the centered layout
         */
        function renderCenteredLayout(ctx, width, height, card, color, isStoryMode, options) {
            ctx.fillStyle = color;
            ctx.textAlign = 'center';

            // Draw title with wrapping
            ctx.font = `bold ${options.titleFontSize}px "Segoe UI", sans-serif`;
            const titleLines = wrapText(ctx, card.title, isStoryMode ? width - 160 : width - 200);
            const titleLineHeight = options.titleFontSize + 15;
            let titleY = options.topPadding + (titleLines.length > 1 ? 0 : 50);

            titleLines.forEach(line => {
                ctx.fillText(line, width / 2, titleY);
                titleY += titleLineHeight;
            });

            // Draw points with wrapping
            ctx.font = `${options.bodyFontSize}px "Segoe UI", sans-serif`;
            const lineHeight = options.bodyFontSize + 25;
            let startY = titleY + 80;

            // Calculate text positioning for bullets
            const maxWidth = isStoryMode ? width - 140 : width - 200;

            card.points.forEach((point, index) => {
                // Now wrap text WITHOUT the bullet character
                const pointLines = wrapText(ctx, point, maxWidth);

                // For the first line of each point, draw a custom bullet
                // Calculate where text starts for proper bullet placement
                const textWidth = ctx.measureText(pointLines[0]).width;
                const bulletX = (width / 2) - (textWidth / 2) - 20; // 20px to the left of text start

                // Draw bullet just once for each point
                drawBulletPoint(ctx, bulletX, startY, color, getBulletStyle('centered'), card.theme);

                // Now draw each line of text (without bullets)
                pointLines.forEach((line, lineIndex) => {
                    ctx.fillText(line, width / 2, startY);
                    startY += lineHeight;
                });

                startY += isStoryMode ? 40 : 10; // More spacing between points in story mode
            });

            renderCardFooter(ctx, width, height, color, isStoryMode);
        }

        /**
         * Render the split layout
         */
        function renderSplitLayout(ctx, width, height, card, color, isStoryMode, options) {
            ctx.fillStyle = color;

            // Draw title with wrapping
            ctx.textAlign = 'center';
            ctx.font = `bold ${options.titleFontSize}px "Segoe UI", sans-serif`;
            const titleLines = wrapText(ctx, card.title, isStoryMode ? width - 160 : width - 200);
            const titleLineHeight = options.titleFontSize + 15;
            let titleY = options.topPadding + (titleLines.length > 1 ? 0 : 50);

            // Draw title text
            titleLines.forEach(line => {
                ctx.fillText(line, width / 2, titleY);
                titleY += titleLineHeight;
            });

            // Draw separator line with consistent spacing
            const separatorY = titleY + (isStoryMode ? 50 : 30);
            ctx.beginPath();
            ctx.moveTo(100, separatorY);
            ctx.lineTo(width - 100, separatorY);
            ctx.lineWidth = 5;
            ctx.strokeStyle = color;
            ctx.stroke();

            // Draw points with wrapping
            ctx.textAlign = 'left';
            ctx.font = `${options.bodyFontSize}px "Segoe UI", sans-serif`;
            const lineHeight = options.bodyFontSize + 25;
            let startY = separatorY + (isStoryMode ? 90 : 70);

            card.points.forEach((point, index) => {
                const pointLines = wrapText(ctx, point, isStoryMode ? width - 180 : width - 250);

                // Draw bullet just once for each point
                drawBulletPoint(ctx, 100, startY, color, getBulletStyle('split'), card.theme);

                // Draw each line with proper indentation
                pointLines.forEach((line, lineIndex) => {
                    ctx.fillText(line, 130, startY);
                    startY += lineHeight;
                });

                // Add extra space between different points
                startY += isStoryMode ? 40 : 15;
            });

            renderCardFooter(ctx, width, height, color, isStoryMode);

        }

        /**
         * Render the boxed layout
         */
        function renderBoxedLayout(ctx, width, height, card, color, isStoryMode, options) {
            ctx.fillStyle = color;

            // Draw title with wrapping
            ctx.textAlign = 'center';
            ctx.strokeStyle = color;
            ctx.lineWidth = 5;

            // Measure title to determine box height
            ctx.font = `bold ${options.titleFontSize}px "Segoe UI", sans-serif`;
            const titleLines = wrapText(ctx, card.title, isStoryMode ? width - 160 : width - 240);
            const titleLineHeight = options.titleFontSize + 15;
            const titleBoxHeight = Math.max(120, titleLines.length * titleLineHeight + (isStoryMode ? 100 : 80));

            // Draw title box with adjusted height
            const titleBoxY = options.topPadding;
            ctx.strokeRect(100, titleBoxY, width - 200, titleBoxHeight);

            // Calculate vertical centering within box
            const totalTextHeight = titleLines.length * titleLineHeight;
            const verticalPadding = (titleBoxHeight - totalTextHeight) / 2;
            let titleY = titleBoxY + verticalPadding + titleLineHeight * 0.8;

            // Draw title text
            titleLines.forEach(line => {
                ctx.fillText(line, width / 2, titleY);
                titleY += titleLineHeight;
            });

            // Set up for points
            ctx.textAlign = 'left';
            ctx.font = `${options.bodyFontSize}px "Segoe UI", sans-serif`;
            const lineHeight = options.bodyFontSize + 25;
            let startY = titleBoxY + titleBoxHeight + (isStoryMode ? 90 : 70);

            // Get background color based on theme
            const boxBackground = card.theme === 'theme-dark'
                ? 'rgba(255, 255, 255, 0.25)'
                : 'rgba(0, 0, 0, 0.1)';

            // Draw each point
            card.points.forEach((point, index) => {
                const pointLines = wrapText(ctx, point, isStoryMode ? width - 180 : width - 250);
                const pointBoxHeight = Math.max(60, pointLines.length * lineHeight + (isStoryMode ? 30 : 20));

                // Draw box for each point
                ctx.fillStyle = boxBackground;
                ctx.fillRect(80, startY - 35, width - 160, pointBoxHeight);

                // Draw bullet and text with proper color
                ctx.fillStyle = color;

                drawBulletPoint(ctx, 100, startY, color, getBulletStyle('box'), card.theme);

                // Draw each line of text
                pointLines.forEach((line, lineIndex) => {
                    ctx.fillText(line, 130, startY);
                    startY += lineHeight;
                });

                // Add space between points
                startY += isStoryMode ? 50 : 35;
            });

            renderCardFooter(ctx, width, height, color, isStoryMode);

        }

        /**
         * Download a single card as PNG
         */
        function downloadCard(index) {
            const card = cardData[index];
            const canvas = document.getElementById(`canvas-${index}`);

            // Add a small delay to ensure rendering completes
            setTimeout(() => {
                try {
                    // Create a safe filename from the title
                    const filename = `${card.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;

                    // Convert canvas to data URL and download
                    const dataUrl = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = filename;
                    link.href = dataUrl;
                    link.click();
                } catch (error) {
                    console.error('Error downloading card:', error);
                    alert('Sorry, there was a problem downloading the card. Please try again.');
                }
            }, 500); // 500ms delay to ensure image loading completes
        }

        /**
         * Download all cards as PNG images
         */
        function downloadAllCards() {
            const globalFormat = document.getElementById('global-format-select').value;

            // Update all canvases to selected format
            cardData.forEach((card, index) => {
                const canvas = document.getElementById(`canvas-${index}`);
                const orientationSelect = document.getElementById(`orientation-select-${index}`);

                // Update orientation select
                orientationSelect.value = globalFormat;

                // Update canvas size
                const selectedOrientation = ORIENTATIONS.find(o => o.id === globalFormat);
                canvas.width = selectedOrientation.width;
                canvas.height = selectedOrientation.height;

                // Re-render card
                renderCardToCanvas(canvas, card);

                // Download after short delay
                setTimeout(() => {
                    downloadCard(index);
                }, index * 500);
            });
        }

        function renderCardBorder(ctx, width, height, color) {
            // Add subtle corner accents
            const cornerSize = 40;
            const margin = 20;

            ctx.strokeStyle = adjustColor(color, 0.5);
            ctx.lineWidth = 2;

            // Top left corner
            ctx.beginPath();
            ctx.moveTo(margin, margin + cornerSize);
            ctx.lineTo(margin, margin);
            ctx.lineTo(margin + cornerSize, margin);
            ctx.stroke();

            // Similar for other corners...
        }

        // Add this at the top of your script, outside any functions
        const logoImage = new Image();
        logoImage.src = 'NAFO-Forum-logo.png';

        // Then replace the existing renderCardFooter with this version
        function renderCardFooter(ctx, width, height, color, isStoryMode) {
            // Use the pre-loaded logo
            if (logoImage.complete) {
                // Logo is already loaded, draw immediately
                drawFooterContent();
            } else {
                // Wait for logo to load
                logoImage.onload = drawFooterContent;
            }

            function drawFooterContent() {
                const logoHeight = isStoryMode ? 80 : 60;
                const logoWidth = (logoImage.width / logoImage.height) * logoHeight;
                const logoY = height - (isStoryMode ? 80 : 40) - logoHeight;

                // Draw logo on the left
                ctx.drawImage(logoImage, 40, logoY, logoWidth, logoHeight);

                // Draw link text on the right
                ctx.font = `500 ${isStoryMode ? '24px' : '20px'} "Segoe UI", sans-serif`;
                ctx.fillStyle = color;
                ctx.textAlign = 'right';
                ctx.fillText('nafoforum.org', width - 40, height - (isStoryMode ? 100 : 60));
            }
        }

        function getBulletStyle(layout) {
            switch (layout) {
                case 'split':
                    return 'diamond';
                case 'box':
                    return 'shield';
                case 'centered':
                    return 'arrow';
                default:
                    return 'circle';
            }
        }
        /**
         * Draw a custom bullet point with accent color
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         * @param {number} x - X position
         * @param {number} y - Y position
         * @param {string} color - Text color
         * @param {string} style - Bullet style
         * @param {string} themeClass - Current theme class
         */
        function drawBulletPoint(ctx, x, y, color, style = 'diamond', themeClass = 'theme-blue') {
            const size = 14; // Slightly larger size for better visibility
            const centerY = y - size / 2 - 5;

            // Get accent color using color theory
            const accentColor = getBulletAccentColor(color, themeClass);

            ctx.save();

            // Add subtle shadow for depth
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            // Use accent color instead of text color
            ctx.fillStyle = accentColor;

            switch (style) {
                case 'diamond':
                    // Diamond shape
                    ctx.beginPath();
                    ctx.moveTo(x, centerY - size / 2);
                    ctx.lineTo(x + size / 2, centerY);
                    ctx.lineTo(x, centerY + size / 2);
                    ctx.lineTo(x - size / 2, centerY);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'shield':
                    // Shield shape for protection themes
                    ctx.beginPath();
                    ctx.moveTo(x, centerY - size / 2);
                    ctx.lineTo(x + size / 2, centerY - size / 3);
                    ctx.lineTo(x + size / 2, centerY + size / 4);
                    ctx.lineTo(x, centerY + size / 2);
                    ctx.lineTo(x - size / 2, centerY + size / 4);
                    ctx.lineTo(x - size / 2, centerY - size / 3);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'arrow':
                    // Arrow for directional emphasis
                    ctx.beginPath();
                    ctx.moveTo(x - size / 2, centerY - size / 3);
                    ctx.lineTo(x + size / 2, centerY);
                    ctx.lineTo(x - size / 2, centerY + size / 3);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'circle':
                    // Simple circle with gradient for depth
                    const gradient = ctx.createRadialGradient(
                        x, centerY, 0,
                        x, centerY, size / 2
                    );
                    gradient.addColorStop(0, lightenColor(accentColor, 0.2));
                    gradient.addColorStop(1, accentColor);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, centerY, size / 2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }

            ctx.restore();
        }

        /**
         * Get an accent color for bullet points based on color theory
         * @param {string} baseColor - The text/main theme color
         * @param {string} themeClass - The theme class
         * @return {string} An accent color that pops
         */
        function getBulletAccentColor(baseColor, themeClass) {
            // Extract RGB components from the base color
            let r, g, b;

            if (baseColor.startsWith('#')) {
                r = parseInt(baseColor.slice(1, 3), 16);
                g = parseInt(baseColor.slice(3, 5), 16);
                b = parseInt(baseColor.slice(5, 7), 16);
            } else if (baseColor.startsWith('rgb')) {
                const parts = baseColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
                if (parts) {
                    r = parseInt(parts[1]);
                    g = parseInt(parts[2]);
                    b = parseInt(parts[3]);
                }
            }

            // If no valid color format was found, return a fallback
            if (r === undefined) return '#fc6d26';

            // Create different accent strategies based on themes
            switch (themeClass) {
                case 'theme-blue':
                    // Complementary orange accent for blue theme
                    return '#fc6d26'; // Vibrant orange

                case 'theme-green':
                    // Rose/magenta accent for green theme
                    return '#e64980'; // Vibrant pink

                case 'theme-purple':
                    // Gold accent for purple theme
                    return '#fcc419'; // Bright gold

                case 'theme-sunset':
                    // Teal accent for sunset theme
                    return '#0ca678'; // Teal

                case 'theme-dark':
                    // Vibrant accent for dark theme that stands out
                    return '#3bc9db'; // Bright cyan

                case 'theme-red':
                    // Contrasting accent for red theme
                    return '#4dabf7'; // Bright blue

                default:
                    // Create a complementary color by inverting the RGB values
                    return `rgb(${255 - r}, ${255 - g}, ${255 - b})`;
            }
        }

        /**
         * Draw watermark image on the canvas
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         * @param {number} width - Canvas width
         * @param {number} height - Canvas height
         * @param {Object} card - The card data
         */
        function drawWatermark(ctx, width, height, card) {
            // Get category, or use a customWatermark if specified
            const imageKey = card.customWatermark || card.category || "INTRODUCTION";
            const image = categoryImages[imageKey];

            if (image && image.complete && image.naturalHeight !== 0) {
                ctx.save();

                // Set global alpha for transparency
                ctx.globalAlpha = 0.08; // Very subtle watermark

                // Calculate sizing to maintain aspect ratio while covering the canvas
                const aspectRatio = image.naturalWidth / image.naturalHeight;
                let drawWidth, drawHeight, x, y;

                if (width / height > aspectRatio) {
                    // Canvas is wider than image
                    drawWidth = width;
                    drawHeight = width / aspectRatio;
                    x = 0;
                    y = (height - drawHeight) / 2;
                } else {
                    // Canvas is taller than image
                    drawHeight = height;
                    drawWidth = height * aspectRatio;
                    x = (width - drawWidth) / 2;
                    y = 0;
                }

                // Draw the image
                ctx.drawImage(image, x, y, drawWidth, drawHeight);

                // Restore the context
                ctx.restore();
            }
        }

        /**
         * Determine the category for a card
         * @param {Object} card - The card data
         * @return {string} The category name
         */
        function getCardCategory(card) {
            // Check if this card is a category header (title is in ALL CAPS)
            if (card.title === card.title.toUpperCase() && card.title in categoryImages) {
                return card.title;
            }

            // Look for "Fighting Disinformation" in the title - these belong to counter-strategies
            if (card.title.includes("Fighting Disinformation")) {
                return "COUNTER-STRATEGIES & DEFENSE";
            }

            // For other cards, scan through cardData to find their category
            let currentCategory = "INTRODUCTION";

            for (const dataCard of CARD_DATA) {
                if (dataCard.title === dataCard.title.toUpperCase() && dataCard.title in categoryImages) {
                    currentCategory = dataCard.title;
                }

                if (dataCard.title === card.title) {
                    return currentCategory;
                }
            }

            return "INTRODUCTION"; // Default fallback
        }
    </script>
</body>

</html>