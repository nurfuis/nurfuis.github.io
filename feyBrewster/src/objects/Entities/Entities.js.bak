import { events } from "../../Events.js";
import { GameObject } from "../../GameObject.js";
import { Vector2 } from "../../Vector2.js";
import { iterateChunkTiles } from "../../helpers/iterateChunkTiles.js";

import { Slime } from "./Slime/Slime.js";
import { Spark } from "./Spark/Spark.js";
import { WoodenFermenter } from "./Equipment/WoodenFermenter.js";
import { WoodenKettle } from "./Equipment/WoodenKettle.js";
import { WoodenMashTun } from "./Equipment/WoodenMashTun.js";
import { TwoTop } from "./Furniture/TwoTop.js";

export class Entities extends GameObject {
  constructor() {
    super({});
    
  }
  async removeChunkEntities(chunkId) {
    const entitiesToDespawn = this.children.filter((child) => child.chunkId === chunkId);

    for (const entity of entitiesToDespawn) {
      await new Promise((resolve) => setTimeout(() => {
        entity.despawn();
        resolve();
      }, 0));
    }
  }
  async addChunkEntities(chunkX, chunkY, world, chunkData, chunkId, overlay) {

    if (chunkData.layers && chunkData.layers[2] && chunkData.layers[2].objects) {
      
      const numObjects = chunkData.layers[2].objects.length;
      for (let i = 0; i < numObjects; i++) {
      	const entity = chunkData.layers[2].objects[i];
        
        const entityX = entity.x + chunkX * 512;
        const entityY = entity.y + chunkY * 512;       
        
				if (entity) {
          let newEntity;
					switch(entity.type) {
						case "Slime":
							newEntity = new Slime(chunkId, entity);
							break;
              
						case "Spark":
							newEntity = new Spark(chunkId, entity);
							break;
              
						case "WoodenFermenter":
							newEntity = new WoodenFermenter(entityX, entityY, world, chunkId, overlay, entity);
							break;
              
						case "WoodenKettle":
							newEntity = new WoodenKettle(entityX, entityY, world, chunkId, overlay, entity);
							break;
              
						case "WoodenMashTun":
							newEntity = new WoodenMashTun(entityX, entityY, world, chunkId, overlay, entity);
							break;
              
						case "TwoTop":
							newEntity = new TwoTop(entityX, entityY, world, chunkId, overlay, entity);
							break;
                            
					}
          if (newEntity) {
            this.addChild(newEntity);  
            newEntity.joinWorld(entityX, entityY, world);
            newEntity.spawn();
          }
        }          
      }    
    }
  }  
}


